const { writeFile } = require("fs/promises");
const { resolve } = require("path");
const { readdir, readFile } = require("fs").promises;
const jestConfig = require("../../jest.config.js");

/*
To avoid repeating ourselves, the idea is to generate the "import" tests before running the test suite, by:
- parsing every "require" tests
- replacing "require" calls with "import"
- fs.writeFile the "import" tests (overwriting those who exists)
*/

// /!\ Windows nodejs devs: please get either WSL or VirtualBox :>
const getFilenameFromPath = (path) => {
  const splittedFilename = path.split("/");
  return splittedFilename[splittedFilename.length - 1];
};

// Get array of files to ignore from /jestconfig.json
const filesToIgnore = jestConfig.testPathIgnorePatterns.map((filepath) => {
  const splittedFilename = filepath.split("/");
  return splittedFilename[splittedFilename.length - 1];
});

// List every test file "with whizbang"(tm) https://stackoverflow.com/a/45130990/11894221
const getFiles = async (dir) => {
  const dirents = await readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    dirents.map((dirent) => {
      const res = resolve(dir, dirent.name);
      return dirent.isDirectory() ? getFiles(res) : res;
    }),
  );
  const testFiles = files.flat(2).filter((filepath) => {
    const filename = getFilenameFromPath(filepath);
    return (
      filename.includes(".js") && !filesToIgnore.includes(filename) && !filepath.includes("import")
    ); // whizbang++
  });
  return testFiles;
};

// Split string into array of lines, then perform the relevant edits
const editString = (jsString) => {
  const lines = jsString.split("\n");
  const editedLines = lines.map((jsLine) => {
    const isThisARequire = /^(?=.*\brequire\b)/g;
    if (isThisARequire.test(jsLine)) {
      /* Patterns we need to handle:
				1- require("dotenv").config();
				2- const imgbbUploader = require("string");
				3- const stuff = require("string");
				4- const { csv } = require("string"); 
			*/

      // Handle pattern 1
      if (jsLine.includes("config()")) {
        return 'import "dotenv/config";';
      } else {
        const path = jsLine.slice(jsLine.indexOf("(") + 1, jsLine.indexOf(")"));

        // Handle pattern 2
        if (jsLine.includes("const imgbbUploader = require")) {
          return `import { imgbbUploader } from ${path.replace("cjs", "esm")};`;
        }

        // Handle patterns 3 & 4: take stuff to import
        const stuffToImport = jsLine
          .split("=")[0]
          // replace keyword
          .replace("const", "import");

        // Glue it with 'path'
        return `${stuffToImport}from ${path};`;
      }
    }
    // For clarity, let's edit the test description to mention it being an "export" test
    else {
      return jsLine.replace(/\btest\("\b(?!\bESM:\b)/g, 'test("ESM: ');
    }
  });
  return editedLines.join("\n");
};

const codegen = async () => {
  // Get array of test files paths
  const testFiles = await getFiles("./src/__tests__/");

  // Promises must be kept preciously
  const jsStringsPromises = [];

  testFiles.forEach((file) => {
    jsStringsPromises.push(
      readFile(file, "utf-8")
        .then((string) => {
          const edited = editString(string);
          const pureFilename = getFilenameFromPath(file).replace(".js", ".mjs");
          return writeFile(`${__dirname}/import_autogenerated/${pureFilename}`, edited);
        })
        .catch((e) => {
          console.error("Problem in readFile.catch\n", e);
          throw e;
        }),
    );
  });

  await Promise.all(jsStringsPromises).catch((e) => {
    console.error("Catch in promise.all", e);
    throw e;
  });
  return null;
};

codegen();
